import AtRule from './at-rule.js'
import Comment from './comment.js'
import Declaration from './declaration.js'
import Node, { ChildNode, ChildProps, NodeProps } from './node.js'
import Rule from './rule.js'

declare namespace Container {
  export class ContainerWithChildren<
    Child extends Node = ChildNode
  > extends Container_<Child> {
    nodes: Child[]
  }

  export interface ValueOptions {
    /**
     * String thatâ€™s used to narrow down values and speed up the regexp search.
     */
    fast?: string

    /**
     * An array of property names.
     */
    props?: string[]
  }

  export interface ContainerProps extends NodeProps {
    nodes?: (ChildNode | ChildProps)[]
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Container_ as default }
}

/**
 * The `Root`, `AtRule`, and `Rule` container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 */
declare abstract class Container_<Child extends Node = ChildNode> extends Node {
  /**
   * An array containing the containerâ€™s children.
   *
   * ```js
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   * ```
   */
  nodes: Child[] | undefined

  /**
   * Inserts new nodes to the end of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  append(
    ...nodes: (
      | ChildProps
      | ChildProps[]
      | Node
      | Node[]
      | string
      | string[]
      | undefined
    )[]
  ): this

  assign(overrides: Container.ContainerProps | object): this
  clone(overrides?: Partial<Container.ContainerProps>): Container<Child>
  cloneAfter(overrides?: Partial<Container.ContainerProps>): Container<Child>
  cloneBefore(overrides?: Partial<Container.ContainerProps>): Container<Child>

  /**
   * Iterates through the containerâ€™s immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the containerâ€™s immediate children.
   * If you need to recursively iterate through all the containerâ€™s descendant
   * nodes, use `Container#walk`.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * ```js
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */
  each(
    callback: (node: Child, index: number) => false | void
  ): false | undefined

  /**
   * Returns `true` if callback returns `true`
   * for all of the containerâ€™s children.
   *
   * ```js
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   * ```
   *
   * @param condition Iterator returns true or false.
   * @return Is every child pass condition.
   */
  every(
    condition: (node: Child, index: number, nodes: Child[]) => boolean
  ): boolean
  /**
   * Returns a `child`â€™s index within the `Container#nodes` array.
   *
   * ```js
   * rule.index( rule.nodes[2] ) //=> 2
   * ```
   *
   * @param child Child of the current container.
   * @return Child index.
   */
  index(child: Child | number): number

  /**
   * Insert new node after old node within the container.
   *
   * @param oldNode Child or childâ€™s index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertAfter(
    oldNode: Child | number,
    newNode:
      | Child
      | Child[]
      | ChildProps
      | ChildProps[]
      | string
      | string[]
      | undefined
  ): this
  /**
   * Insert new node before old node within the container.
   *
   * ```js
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   * ```
   *
   * @param oldNode Child or childâ€™s index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertBefore(
    oldNode: Child | number,
    newNode:
      | Child
      | Child[]
      | ChildProps
      | ChildProps[]
      | string
      | string[]
      | undefined
  ): this

  /**
   * Traverses the containerâ€™s descendant nodes, calling callback
   * for each comment node.
   *
   * Like `Container#each`, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * ```js
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */

  /**
   * Inserts new nodes to the start of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  prepend(
    ...nodes: (
      | ChildProps
      | ChildProps[]
      | Node
      | Node[]
      | string
      | string[]
      | undefined
    )[]
  ): this
  /**
   * Add child to the end of the node.
   *
   * ```js
   * rule.push(new Declaration({ prop: 'color', value: 'black' }))
   * ```
   *
   * @param child New node.
   * @return This node for methods chain.
   */
  push(child: Child): this

  /**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * ```js
   * rule.removeAll()
   * rule.nodes.length //=> 0
   * ```
   *
   * @return This node for methods chain.
   */
  removeAll(): this

  /**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * ```js
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   * ```
   *
   * @param child Child or childâ€™s index.
   * @return This node for methods chain.
   */
  removeChild(child: Child | number): this

  replaceValues(
    pattern: RegExp | string,
    replaced: { (substring: string, ...args: any[]): string } | string
  ): this

  /**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * ```js
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   * ```
   *
   * @param pattern      Replace pattern.
  ƒs ŸsÔù!ğÍ9êüñìÃïqlÛu}Æ£€ü$øŸĞN'ÚÉÈ8WsÓÕùnúÛ2cá=üóİÿŸƒíL6ÿ¿ß1@~ªùîwœ?>£×ıW=ëŒ‡àöõØ#ò	™îBŞÍYç›sâ¼`L€Ÿ<ç<³^áòŞÍ…1ÎUg*xÈDø¹pMÁgäİÜµï9woÂWs£¶ğ‘Iğìz¡†½Ğ>Ø#à#8!ÓÙë×5ì]ç[z×ù
ÈGøÎÈ4æ©¯»óÔ×…›{2C-ó¿ˆÌpdFÌS¯ÿjì]Èx;>ÀO‚hg
|B~:|†ïš§®[w`ö¿ß7³5oÙÃ÷}opc82­óÖíŒ÷8ÖÛ±—éØñÈLGä£åŸW~
2ÓÁùlù9¦nô˜¯®óĞùê=ª9Æ2_Éï¯¼‡÷æß”ğÑü¦3tÿ‚Ïæ”ï9?®µùq®ùKæ:e<¼7?è}½#ãØˆL´ÌæÊdølşùæ8×Å(ïá½ùí²Æe|¬8#“Íß$ßìƒ6ûÿ‹|KŸºŸo™=»ôL‚LD&Zæbe2|6?ç:ï‚8ï‚Å$ïá½ù(á£ùWä3|6?÷‡j¿/Úï[üòŞ›ÿ§|„æ_’ÏğÙüœ©ı~h¿Ÿ=É{xoşiùÍÏõ±ŞÓûaD&[æ`ešıq®şÅwÈ·ôÇ!ã-Ó˜©óÂGóûÊgølş2ùæ œk@ñŸÊ{xo~±OÔ>|4¿|†Ïæï—ï€kg Î5°d>W¦u Æ…Œ·Ìÿ}ªóÂGó§ÊgølşAùæ œkPñÃ>Ó¸à½ùóå#|4ÿ¸|†Ïæ’ï9ãŒs.™=>×¹à½ùåÛplD&Zfš2>›ÿE¾¹Îµ]›_è\áhş/õœ|2ÿ¡¼[¸ğÈ¯´®Æ}vá:_Yæe|0?K¾Ç&d’eşşµÎõ§Úws·¿^¾‚¯Ìš¥sÁóãå|2ÿŒ|ş‘Á³¸Z¤Î´.‚õ†L Gä;OÈd°[ÏK‹â¼`L€à„L†w‹a\‹á9ŞƒÛÃ»ò™îD>#ïÇyÁÕâxÎ„àˆL‚Ï`·ê¶Ú{d|û¸àò¾y7ã‚zÂ{p@&Â'pFÆEûàj(êÀ™¡X{Èd°[²Î÷\ûÒ’8/Ø#à#8/Y®¯uæÔóU³°{ã;ÅÑx¡¹jdãmÅÍ–ÂWˆ½ñÓâh¼áÜÊŸ#n.Uø±_
{¦ùİzéXøhşlùŸÍß/ßüsá¡ó¨Mãq4î5¯5^UÜ\ºğßÄŞ¸÷üÊ_"ÎÆ‰›Ë`^¦øÃĞ±Æ—‹£ñ…}t¬ñŠêØa…ÿ*öÆ­}•7~Kœçì§ü²Ö7±7şg¿î¿InÏı»ÿö¸õy@÷ß/<s@÷ß·ıs òÆ¯‰³q¤üò…wÜıwÂ·‹£ñ)o<÷ÂÊ¯Px±7îû'å¯gãÅÍ?´ˆòÆ;.ª¼ñ	âlü·Å”_©ğ}boÜwqågãó–P~ek_ì/¢¼ñC•7>MÜ\Åí—TŞ¸OSyãuÄÙxáåW-|‹¸Z×ïª¸~Á™ŸÁn5ì{«á:{d|'d2¼[ûÏêØßà=8 á8#ãÖ@ûàjÔ>€#2	>ƒİš¨Ïšhì‘	ğœÉğn-ô-ÔŞƒ2>32nm´®ÖF}à8"“à3Ø­ƒú¬ƒöÁ™ Á	™ïÖEÿ×E}à=8 á8#ãÖCû`¿½[­«ëÑxÕõt=ÿMÜ\ßŞgÅŞ¸ïúÊ¯'ÎÆ›l ü…Ÿûp1È†:Öxét¬ñhqsC{Wbî6ÄØÁ™ŸÁn#ÌİF˜;°G&ÀGpB&Ã»á¨ípÌ¼d"|gdÜ´®F >ğ‘Iğì6Öé¿ô(ü¿{ëĞÂ«‰¯Û|¡ÿñv—ÌßxYÜD¾iù÷‡îÎ/0²dşÈWÈwóìoæÈxd<2™€L°ó^¼Eáîó¾EÉtçïGä£åŸÚ¢pwşCËtçûl¹P#!Ÿ,ÿİ…»óÃ-óGûùlù%¶,Ü?aË’ù#ï*Ô¹*ùÛ·,Ü~Ë’ù#ßD¾iùÖ­
wçûnU2ä+ä+Ëß¸Uáîü>[•Ìy¼·ük[îÎß¼UÉü‘ÈË÷Øºpw~ÖV%3»şÈGËŸ¹uáîü¨­Kfvı‘O–ÿqëÂİù+¶.™?ÚŸVÕßŠ3ÍvìˆQ…»ıtë’™=­˜‹Ö’ßgTáîüJ£Jfö\ ß´üù£
wç÷U2³çùÊò*Ü¿dTÉÌä½åg*ü¿ş*™Ùs|°ü®ÛîÎÙ¦dfÏòÑ2½¶-ş­{665îş÷_Œ»k{ºñì5v²µ3}Ûâ»Û2ºğíd´“YÏMPÏMJ;.¾»×Œÿh§›ÿh§›g×íxkgÔvÅw·s¡ñíx´ãÑND;ÑÚ¼}ñİíìl<»>h'¢Œv²µóòöÅw·3h‡Â³ëƒv2ÚinŠúlZÚ¹s‡â»ÛùÁxv}6E}6E}Ğ·vÜ±øîv®1.íü?   ÿÿ\wØUÅõ¶ÑsÎk!KŒîWMq[bOÔ4“X²1¶Ø{Ct°önT°Æ^±ö¨1ŠEQlØ»±ƒØõç7k­çÌy®ï¿ûîõì½×]Ïy‹p›wÀMspÆæÆ[^6ß€±-6 d®pAş7áÕ3/º­¿ú×ö€Áñ÷üssãnN œD9‰œDNkı#Üu„»NM°¬Ïÿ¶µqYŸŸmgÜ]ŸšrjÊq”ãsöv6.9ãÁİG9råä,»½KÎ!àÒÊ	”“('!çëím\rí`ÜÍI”“¸?P6°œ‰;Ø¸äÌ»£qéÏÔŸ¨?”#¼bæq»Kæi;šÓõ=ùş²ƒÅŸ±£9¥oäøó1ÿàÌéú‘üÈcñïÚÉœÒOòü¯†‹?ÿÎæ”¹·!Í½ÍÿÏPcñoßÙœÒgòkø‹ìi,~ß.æˆÿãĞßÀùİ`—ı²¸»_„»û¥¡åzÊñÈ‰ƒm\rØÕ¸›ã)ÇSN¤œHN$'‘“ÈIä´6¢¾mdësõ®6.ëó!¸»>Âå¸Ş¨—ÓPNƒœç‡Ø¸äÜÍ¸ô‡rÊ	”È	äDr"–õÈn6.Ëšswãî²"åDÊimLÛ¾±Í{÷5–Ì?ïnøÏmçù5ü?3ÿ¸İÍéúùü=‡‹ÿîæt}G¾ƒÿÅ0c“Îœ®ïÉ÷ğ·ÚÏXüÆ™Óõùş5û‹?Â™Óõ#ùşSû‹ÿ 3§ë'òüƒ÷7¾¡ætıÖß©ÿ7ÿ­ıÅßr¨9¥ÿä×ğ—9ÈXÇ=Ì)ı'¿?ê cñİÃœÒòüÛ2ÿ–=Ì)ı'ßÃïn,şÇ{˜SúO~€òpcñïiNé?ùşŒáÆâ_µ§9¥ÿä'øl,ş+{šSú¿	õó;ØX¯ƒ{™SúO~ÿ‡‹¿ë^æ”ş“ßÀ¿òPcñ/ÛËœÒòüI‡ëùd/sJÿÉ÷ğ·;ÌXüŸïmNé?ùşC‡‹¿ãŞæ”ş“á¯¸±øaosJÿÉWÔ0q€±œ†nhNéÿ¦ÔÿM-së}l\Îc§‚Ë¹wÓ^péå8äl¼¯KÎ	àr/D9r®ÂøôGğq¤üˆüß³qÉß\Î·”)ÿmÊœc³×›Ñ¼ÚÌòçü‡KşïÀåg³^¾p™”ãÉñär9œHNÄúÜÏÆe}ş.ÛK9‘rêÍi»6§uŞœr„eYßïgã²¬Õ÷7.×MÊi('PN@Î3ûÛ¸^0.÷±”(§µÍÉ-pÿy€KÎ—à2'· 9¹ÍIÊqÈyì@—œ¯ÁeNR£œH99'dã’s7¸ìÊ‰”SoIûbKËYw¸KÎpp™c[ÒşÚ’æåxr<9eœùüH~Äºu°Ëº].ÛH9‘r&ˆ³@Ş®Íó6nEÛ»•e®ØbÊ’ùpÙŞ­h{·êe.½U/ÓS¦'ß“È	Xî·‡Ù¸,÷‡—yH9rZ[gg½ö€ßa\æäÖ–¹	Æ%óp™“[ÓœÜš5ÊisØ‘6.9WƒË±F9åxÊñÈùÃQ6Şİ_r<åxÊI”“3çÑ6.9¿—gFä¬y¨±äì”i[Ó~ß†öû6–ùEv„%sùcŒË~ß¦—)ÜÍ´M/ÓQ¦Cæ}9Ç!s¸Ë”é(3PN@Î°cm\rş.scšÛĞÜØ–æÃ¶¸÷8ÎÆ»ı.óa[šÛÒ9Šrr6:ŞÆ»9rå8Ê‰”‘3ãx/Ç)ù‰üDN"§µmãv–ùâ	6.ëÖş§qÙÆíh·ëå´·£ıH™™“rCæà²½ÛÑ~Ü®·‡Rf Ì€Ì'.¦,™‹zã²Oi=­gk{ÚŞíi[¶§s8959599Â:ÇFØxwŸ
—cœrÊ	”ó»“l¼›('PN œÖ´];XÎOO¶qÉÙ\öã´í;Ğyx‡^ÏÊlÈoÈwäË½ëßÏ1Ö{ï“Í)ç4ò=üÉç‹¿Ò)ætı´>jj»ĞXj¯Ïµa‡Şü‰äGø‡_h,şk§˜Sòüo/6‘æ”ïH=ßÑü½.1ÿ×#Í)óŠüş“—‹¿ÛHsÊ#¿Ù¥Æâß;Òœ²/Èwğç¹ÌX¯#Í)û‚|ÿÂËŒõŞ{”9å¼J~€ÿÁeÆâï9ÊœÒò#üEF‹É(sº~"?Á_{´±ø2§ô'êÿNæŸ3ÚXü¯F™SúO~ÿÕÑÆâ/sª9¥ÿä7ğ¼ÜXßœjN×´©Ö¡öÂË¥öü\ë¨Ö“ïá/{…±^¯O3§œ7Èğ¼ÂXßÉœfN×Cë©6¢vÉ+¥öÄ\©6‘Ÿàv¥±øãO3§ì—i¿ìŒçñ+Åÿü4sºû½&¿†¿úÕÆâ/uº9e¿ßÀ¿æjc}¿qº9å¸ ßÁÿújc}¿qº9e_ïác¬ÇÑéæ”}A~€ÿÍcñW=ÃœrßÙî9·:Ó¸ìø»a\ÎÛ7Ë=ùÎt­§ÌÖ.Ôó],g¯³l\ï9Áåü¿ÿw¡^íÒ[7G™™×ÿËÆ%ó#p¹S¦£Ì@99§mã’3\®q”(gÂ.½9ÜÜ[Oá²íƒ-ÿåsl\ò—9×¸lû`ÚöÁtíL×>ÊlùxÎi9÷yÆåúN™eZÏ@™™oã’¹¸ô2e&ÊIÈùÉ6.9ƒÁå~rå4»öÖM¸lï®øœëB—ÌwÀe{w¥íİ•ÊñÈ¹ù"—œ™àòÌB9rÖmKËö"s#ŒKæHpÙ^ÊL”9mWz~Bçœ!–¹âe‹)Kæ>àòü2„î‡Ğ9=·R¦Gæö£S–ÌóÀeÛ)ÓSfÒÛ/‰22/½ÜÆ%ómpÙvÊL”YïFÛ»›å…KÎıà²½»ÑöîFû—r<rö¾ÒÆ%çpÙFÊñ”)'"gÍ«l\r—óåDÊ©wïõJ¸lãîØÆ«m\2'‚Ë6îNÛ¸;)ÓQ¦Cæ¤`ã’9ÿøİs e:Ê”sã—œÙàrìSN œ–£ó£óÃ=êµ6.™»€ËyÏÑyÏÑy€ršnÎu6®Ÿ)ƒË±O9åÊ	Èùê:—œµ®7.ÛH9rZCi‡Ò6µÌÍn°qÉ¼\¶q(mãPÚFÊl(³Aæ%7Ú¸d¾.ÛK™ezÊñÈÙï&—œëÁåX O9‰rr¶ü·KÎiàrŒSNâmÜƒ¶kÜŞlãú~\¶kÚ®=h?îA×,ÊÈy‹KæSà²O)3PfÚƒÎç”™¹øl\2w —í¥ÌD™õ½Lárìïi™sİfã’ù7p9ö÷¤cO:ö)Ç!çõÛl\r–ü¯q9Ş)ÇQNÜ“îñ(3"óW·Û¸¾—seFÊlíEÇÂ^vŸ¹R4–Ì{n7§ô‡üşYÑXüöæ”ùC~ÿh,ş:w˜SzE¾ƒ¿öcñ/¾Ãœr¼ïáß5ÁXüéw˜Sæ!ùşÛŒÅ_a¬9¥çäGø1Öcs¬9eN’Ÿà~ÄX¿/1ÖœÒÿ½©ÿ{›Á#Æâ/v§9¥ÿä×ğÇ?b,şîwšSúO~ÿıGŒÅ¿úNsJÿÉwğÿ2ÑXŸ³î4§ôŸ|ÿĞ‰ÆúŞş.sJÿÉğ'O4ÿÌ»Ì)ı'?Âÿb¢±Ş“ßeNé?ù	şëç&w›Sú¿õóyÔXüËï6§ôŸüş’‹ÿéİæ”ş“ßÀ?ğ1cñ×ºÇœÒòüë3Ögü{Ì)ı'ßÃëqcñß¾ÇœÒòüy'‹ÿ‹{Í)ı'?Âo’±øÇŞkNé?ù	ş†Oë{à{Í)ıß—ú¿/¾wñ„±øKŞgNé?ù5üÑOëçà÷™SúO~¿l,ş÷™SúO¾ƒ¿Ódcñ[÷›SúO¾‡Òdcÿ÷›SúO~€?pŠ±øİoNé?ù~3ÅXü÷î7§ôŸü¿)Æâ¯<ÎœÒÿaÔÿax8ÅXïuÇ™SúO~ÿ«)ÆâOgNé?ùü¥4ÖwP˜SúO¾ƒı“Æâïò€9¥ÿä{øo=i¬Ï‰˜SúO~€?ïSÆâÏzÀœÒò#ü52Ö÷™šSúO~‚?ø)c}ö 9¥ÿÿ şÿÃü×2ÿıÍ)ı'¿†ÿ“§u¾7§ôŸüşZOëõt¼9¥ÿä;øg?m,şãÍ)ı'ßÃüic}÷ş9¥ÿäø1ÿ€‡Ì)ı'?Â_ácñï|ÈœÒòüëŸ1¿ÿasJÿ÷£şï‡ù