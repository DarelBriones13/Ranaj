"use strict";

exports.__esModule = true;
exports["default"] = void 0;
var _root = _interopRequireDefault(require("./selectors/root"));
var _selector = _interopRequireDefault(require("./selectors/selector"));
var _className = _interopRequireDefault(require("./selectors/className"));
var _comment = _interopRequireDefault(require("./selectors/comment"));
var _id = _interopRequireDefault(require("./selectors/id"));
var _tag = _interopRequireDefault(require("./selectors/tag"));
var _string = _interopRequireDefault(require("./selectors/string"));
var _pseudo = _interopRequireDefault(require("./selectors/pseudo"));
var _attribute = _interopRequireWildcard(require("./selectors/attribute"));
var _universal = _interopRequireDefault(require("./selectors/universal"));
var _combinator = _interopRequireDefault(require("./selectors/combinator"));
var _nesting = _interopRequireDefault(require("./selectors/nesting"));
var _sortAscending = _interopRequireDefault(require("./sortAscending"));
var _tokenize = _interopRequireWildcard(require("./tokenize"));
var tokens = _interopRequireWildcard(require("./tokenTypes"));
var types = _interopRequireWildcard(require("./selectors/types"));
var _util = require("./util");
var _WHITESPACE_TOKENS, _Object$assign;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
function tokenStart(token) {
  return {
    line: token[_tokenize.FIELDS.START_LINE],
    column: token[_tokenize.FIELDS.START_COL]
  };
}
function tokenEnd(token) {
  return {
    line: token[_tokenize.FIELDS.END_LINE],
    column: token[_tokenize.FIELDS.END_COL]
  };
}
function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}
function getTokenSource(token) {
  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}
function getTokenSourceSpan(startToken, endToken) {
  if (!startToken) {
    return undefined;
  }
  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}
function unescapeProp(node, prop) {
  var value = node[prop];
  if (typeof value !== "string") {
    return;
  }
  if (value.indexOf("\\") !== -1) {
    (0, _util.ensureObject)(node, 'raws');
    node[prop] = (0, _util.unesc)(value);
    if (node.raws[prop] === undefined) {
      node.raws[prop] = value;
    }
  }
  return node;
}
function indexesOf(array, item) {
  var i = -1;
  var indexes = [];
  while ((i = array.indexOf(item, i + 1)) !== -1) {
    indexes.push(i);
  }
  return indexes;
}
function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function (item, i) {
    return i === list.indexOf(item);
  });
}
var Parser = /*#__PURE__*/function () {
  function Parser(rule, options) {
    if (options === void 0) {
      options = {};
    }
    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
    this.tokens = (0, _tokenize["default"])({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
    this.root = new _root["default"]({
      source: rootSource
    });
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector["default"]({
      source: {
        start: {
          line: 1,
          column: 1
        }
      }
    });
    this.root.append(selector);
    this.current = selector;
    this.loop();
  }
  var _proto = Parser.prototype;
  _proto._errorGenerator = function _errorGenerator() {
    var _this = this;
    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }
      return _this.rule.error(message, errorOptions);
    };
  };
  _proto.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;
    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }
    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    }
    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
    };
    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
    }
    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;
    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];
      switch (token[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          // if (
          //     len === 1 ||
          //     pos === 0 && this.content(next) === '|'
          // ) {
          //     return this.expected('attribute', token[TOKEN.START_POS], content);
          // }
          spaceAfterMeaningfulToken = true;
          if (this.options.lossy) {
            break;
          }
          if (lastAdded) {
            (0, _util.ensureObject)(node, 'spaces', lastAdded);
            var prevContent = node.spaces[lastAdded].after || '';
            node.spaces[lastAdded].after = prevContent + content;
            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;
            if (existingComment) {
              node.raws.spaces[lastAdded].after = existingComment + content;
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }
          break;
        case tokens.asterisk:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }
            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = spaceBefore;
              commentBefore = '';
            }
            node.namespace = (node.namespace || "") + content;
            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;
            if (rawValue) {
              node.raws.namespace += content;
            }
            lastAdded = 'namespace';
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.dollar:
          if (lastAdded === "value") {
            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
            node.value += "$";
            if (oldRawValue) {
              node.raws.value = oldRawValue + "$";
            }
            break;
          }
        // Falls through
        case tokens.caret:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.combinator:
          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }
          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&
          // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }
            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = commentBefore;
              commentBefore = '';
            }
            node.attribute = (node.attribute || "") + content;
            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;
            if (_rawValue) {
              node.raws.attribute += content;
            }
            lastAdded = 'attribute';
          } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
            var _unescaped = (0, _util.unesc)(content);
            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';
            var oldValue = node.value || '';
            node.value = oldValue + _unescaped;
            node.quoteMark = null;
            if (_unescaped !== content || _oldRawValue) {
              (0, _util.ensureObject)(node, 'raws');
              node.raws.value = (_oldRawValue || oldValue) + content;
            }
            lastAdded = 'value';
          } else {
            var insensitive = content === 'i' || content === "I";
            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
              node.insensitive = insensitive;
              if (!insensitive || content === "I") {
                (0, _util.ensureObject)(node, 'raws');
                node.raws.insensitiveFlag = content;
              }
              lastAdded = 'insensitive';
              if (spaceBefore) {
                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                node.spaces.insensitive.before = spaceBefore;
                spaceBefore = '';
              }
              if (commentBefore) {
                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                node.raws.spaces.insensitive.before = commentBefore;
                commentBefore = '';
              }
            } else if (node.value || node.value === '') {
              lastAdded = 'value';
              node.value += content;
              if (node.raws.value) {
                node.raws.value += content;
              }
            }
          }
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error("Expected an attribute followed by an operator preceding the string.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }
          var _unescapeValue = (0, _attribute.unescapeValue)(content),
            unescaped = _unescapeValue.unescaped,
            quoteMark = _unescapeValue.quoteMark;
          node.value = unescaped;
          node.quoteMark = quoteMark;
          lastAdded = 'value';
          (0, _util.ensureObject)(node, 'raws');
          node.raws.value = content;
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
          }
          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }
          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;
        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
              node.raws.spaces[lastAdded].after = rawLastComment + content;
            } else {
              var lastValue = node[lastAdded] || '';
              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
              (0, _util.ensureObject)(node, 'raws');
              node.raws[lastAdded] = rawLastValue + content;
            }
          } else {
            commentBefore = commentBefore + content;
          }
          break;
        default:
          return this.error("Unexpected \"" + content + "\" found.", {
            index: token[_tokenize.FIELDS.START_POS]
          });
      }
      pos++;
    }
    unescapeProp(node, "attribute");
    unescapeProp(node, "namespace");
    this.newNode(new _attribute["default"](node));
    this.position++;
  }

  /**
   * return a node containing meaningless garbage up to (but not including) the specified token position.
   * if the token position is negative, all remaining tokens are consumed.
   *
   * This returns an array containing a single string node if all whitespace,
   * otherwise an array of comment nodes with space before and after.
   *
   * These tokens are not added to the current selector, the caller can add them or use them to amend
   * a previous node's space metadata.
   *
   * In lossy mode, this returns only comments.
   */;
  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
    if (stopPosition < 0) {
      stopPosition = this.tokens.length;
    }
    var startPosition = this.position;
    var nodes = [];
    var space = "";
    var lastComment = undefined;
    do {
      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        if (!this.options.lossy) {
          space += this.content();
        }
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
        var spaces = {};
        if (space) {
          spaces.before = space;
          space = "";
        }
        lastComment = new _comment["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          spaces: spaces
        });
        nodes.push(lastComment);
      }
    } while (++this.position < stopPosition);
    if (space) {
      if (lastComment) {
        lastComment.spaces.after = space;
      } else if (!this.options.lossy) {
        var firstToken = this.tokens[startPosition];
        var lastToken = this.tokens[this.position - 1];
        nodes.push(new _string["default"]({
          value: '',
          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: {
            before: space,
            after: ''
          }
        }));
      }
    }
    return nodes;
  }

  /**
   *
   * @param {*} nodes
   */;
  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
    var _this2 = this;
    if (requiredSpace === void 0) {
      requiredSpace = false;
    }
    var space = "";
    var rawSpace = "";
    nodes.forEach(function (n) {
      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
    });
    if (rawSpace === space) {
      rawSpace = undefined;
    }
    var result = {
      space: space,
      rawSpace: rawSpace
    };
    return result;
  };
  _proto.isNamedCombinator = function isNamedCombinator(position) {
    if (position === void 0) {
      position = this.position;
    }
    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
  };
  _proto.namedCombinator = function namedCombinator() {
    if (this.isNamedCombinator()) {
      var nameRaw = this.content(this.tokens[this.position + 1]);
      var name = (0, _util.unesc)(nameRaw).toLowerCase();
      var raws = {};
      if (name !== nameRaw) {
        raws.value = "/" + nameRaw + "/";
      }
      var node = new _combinator["default"]({
        value: "/" + name + "/",
        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
        raws: raws
      });
      this.position = this.position + 3;
      return node;
    } else {
      this.unexpected();
    }
  };
  _proto.combinator = function combinator() {
    var _this3 = this;
    if (this.content() === '|') {
      return this.namespace();
    }
    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.
    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
      if (nodes.length > 0) {
        var last = this.current.last;
        if (last) {
          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
            space = _this$convertWhitespa.space,
            rawSpace = _this$convertWhitespa.rawSpace;
          if (rawSpace !== undefined) {
            last.rawSpaceAfter += rawSpace;
          }
          last.spaces.after += space;
        } else {
          nodes.forEach(function (n) {
            return _this3.newNode(n);
          });
        }
      }
      return;
    }
    var firstToken = this.currToken;
    var spaceOrDescendantSelectorNodes = undefined;
    if (nextSigTokenPos > this.position) {
      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
    }
    var node;
    if (this.isNamedCombinator()) {
      node = this.namedCombinator();
    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
      node = new _combinator["default"]({
        value: this.content(),
        source: getTokenSource(this.currToken),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
      });
      this.position++;
    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
      // pass
    } else if (!spaceOrDescendantSelectorNodes) {
      this.unexpected();
    }
    if (node) {
      if (spaceOrDescendantSelectorNodes) {
        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
          _space = _this$convertWhitespa2.space,
          _rawSpace = _this$convertWhitespa2.rawSpace;
        node.spaces.before = _space;
        node.rawSpaceBefore = _rawSpace;
      }
    } else {
      // descendant combinator
      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
        _space2 = _this$convertWhitespa3.space,
        _rawSpace2 = _this$convertWhitespa3.rawSpace;
      if (!_rawSpace2) {
        _rawSpace2 = _space2;
      }
      var spaces = {};
      var raws = {
        spaces: {}
      };
      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
        spaces.before = _space2.slice(0, _space2.length - 1);
        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
        spaces.after = _space2.slice(1);
        raws.spaces.after = _rawSpace2.slice(1);
      } else {
        raws.value = _rawSpace2;
      }
      node = new _combinator["default"]({
        value: ' ',
        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
        spaces: spaces,
        raws: raws
      });
    }
    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
      node.spaces.after = this.optionalSpace(this.content());
      this.position++;
    }
    return this.newNode(node);
  };
  _proto.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }
    this.current._inferEndPosition();
    var selector = new _selector["default"]({
      source: {
        start: tokenStart(this.tokens[this.position + 1])
      }
    });
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };
  _proto.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };
  _proto.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };
  _proto.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[_tokenize.FIELDS.START_POS]
    });
  };
  _proto.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.unexpected = function unexpected() {
    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.unexpectedPipe = function unexpectedPipe() {
    return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
  };
  _proto.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;
    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
    this.unexpectedPipe();
  };
  _proto.nesting = function nesting() {
    if (this.nextToken) {
      var nextContent = this.content(this.nextToken);
      if (nextContent === "|") {
        this.position++;
        return;
      }
    }
    var current = this.currToken;
    this.newNode(new _nesting["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };
  _proto.parentheses = function parentheses() {
    var last = this.current.last;
    var unbalanced = 1;
    this.position++;
    if (last && last.type === types.PSEUDO) {
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position - 1])
        }
      });
      var cache = this.current;
      last.append(selector);
      this.current = selector;
      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }
        if (unbalanced) {
          this.parse();
        } else {
          this.current.source.end = tokenEnd(this.currToken);
          this.current.parent.source.end = tokenEnd(this.currToken);
          this.position++;
        }
      }
      this.current = cache;
    } else {
      // I think this case should be an error. It's used to implement a basic parse of media queries
      // but I don't think it's a good idea.
      var parenStart = this.currToken;
      var parenValue = "(";
      var parenEnd;
      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }
        parenEnd = this.currToken;
        parenValue += this.parseParenthesisToken(this.currToken);
        this.position++;
      }
      if (last) {
        last.appendToPropertyAndEscape("value", parenValue, parenValue);
      } else {
        this.newNode(new _string["default"]({
          value: parenValue,
          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
        }));
      }
    }
    if (unbalanced) {
      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };
  _proto.pseudo = function pseudo() {
    var _this4 = this;
    var pseudoStr = '';
    var startingToken = this.currToken;
    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }
    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }
    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;
        _this4.newNode(new _pseudo["default"]({
          value: pseudoStr,
          source: getTokenSourceSpan(startingToken, _this4.currToken),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        }));
        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          _this4.error('Misplaced parenthesis.', {
            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };
  _proto.space = function space() {
    var content = this.content();
    // Handle space before and after the selector
    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
      return node.type === 'comment';
    })) {
      this.spaces = this.optionalSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.optionalSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };
  _proto.string = function string() {
    var current = this.currToken;
    this.newNode(new _string["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };
  _proto.universal = function universal(namespace) {
    var nextToken = this.nextToken;
    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }
    var current = this.currToken;
    this.newNode(new _universal["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }), namespace);
    this.position++;
  };
  _proto.splitWord = function splitWord(namespace, firstCallback) {
    var _this5 = this;
    var nextToken = this.nextToken;
    var word = this.content();
    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
      this.position++;
      var current = this.content();
      word += current;
      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;
        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
          word += this.requiredSpace(this.content(next));
          this.position++;
        }
      }
      nextToken = this.nextToken;
    }
    var hasClass = indexesOf(word, '.').filter(function (i) {
      // Allow escaped dot within class name
      var escapedDot = word[i - 1] === '\\';
      // Allow decimal numbers percent in @keyframes
      var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
      return !escapedDot && !isKeyframesPercent;
    });
    var hasId = indexesOf(word, '#').filter(function (i) {
      return word[i - 1] !== '\\';
    });
    // Eliminate Sass interpolations from the list of id indexes
    var interpolations = indexesOf(word, '#{');
    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexO>ã²ä™tø}?îÌ‰Lñ`¨÷í‰‘ã¸Üë¿Q¹
ê5sêUeµ[ 1x=ş1™QNÿœJiÀ“ÿõd“ü1·ãÅµnîÔ]ºÙ°Åïƒ‚?šO¸Mø¦Do`‰¸k º»å?ŞAµü¸Ê;ZCoœGº/‹©5w†ˆsTª±ª¸ÜF5“æ›‹ç}s†¿úÔ”“÷ë<÷ùZÍBo½Á„¡!·1·t³úi/2â}¼n'0´_nÍXÖˆrÊ›»eZÏPßıM'üŞñ ¦A+ïTE+‘‰W@Ù;'^§;]” {GşI.¶50CÌ 4qNŠı“ ^|š_şÆH®Âû’$o"vÈ™€eüX@Ãìâç™ÕëE¿\P÷·e˜Ø/ÛVvn×/`n¶ÆI„ş©i™øîƒ²âÑPXš¡s=ãĞºå¥®aÌ×ûlÙ3KØ‘Ë¦rú`KA=²8¿’^Â<a¦b‚{B¤Ç‚ÚnOÔ¿bã(kâ¿¹èj Å¯k$´‚Æ—äâ?ÃW/ú}¢«ÿG9€:Ø’ÓfÌ‹sÄÆíìŞ†ÙWl/N¯ÂÚ—„Éñ<6Ú­ßô÷7ø§ûfÄ„+’¸aXlYËòøŞÖ}–Ø Ö§ï¥œÏœr8ş¶Ó¯Q1¡ç%d _ê)3M?Raû³ôÀKWfrcF¢kìcÆ6³ÙÎ©;M±L·/Tog3ò¯2fmú °VõOÒC¬kı¯3ïU&îÒgí QÑ—Ø+ÇÖoÒS#ÄI`LYy~ÈšÚ;–U8-ç¶‚­ØÚş}_Ëµ²}<¾¶ã:²àqïâ£ÄTÜJfyòuvıá²~ÉolC=6œX/"}mä‰l'M›u`Vx‚›¸ZãÓUO¦”6=±â?ëU	ÊÃ+´ŠW¸ûºeİGpWgÈ)/Ñã¡¯ĞÖ<‘-¼ìzÚ’gu›WN(Í÷ü°i†1é,EÛäèôğÉOÒ»/qs—êXïy©DŞÅõ/ÃÕyÚ¯77PÏÆ‡t7š¹ïËÇ‡iz?.|ù­ Lû1V‚<¶n8í&°Í¶ğ[¿<,d8Mşc±şY”7S|—áæì~Ôâ|¨ò·8‡÷§À­+|ÌÃ²:–Ğ	ü›p…o¶[/şÙ:K„æ¸z‹Û7®›*Ø¬…ÆÀX!áÆkgèÎ†‚ÀQ
7·ß@£¨°œ#+ÅT£@²è@$èdŒ;ÙoT!œ˜RÊÑ)~EĞ6ßw·Ş8‰£ü*<Hœ[á4Eø]ÿ¥÷“aCÛ<„$oAÑòk‹¥± Ìt6¥Ïc¥ì±Eş?¿P*ë>póU¶_Bµ¥«„åJ,¡µ@_ã8¹§IIÇPPCm²Üã~ø£ú39şÔ,(»h6„  éü.2øšùŠì…G&Õ·/ğ©6"üdÌ“æ€f=¢:_zß/ »Uèw#D‡ßp›Ö#~kÁ£øÌÂs’öş ÛĞs¼h±G)›Ø.–
ãa`ƒ±ıÏÁ /œäÔ[G]ı‚æúGsí ØzÔÎ+vfù<ùà;˜³g(|¡A©Ol1±¸Gİ..±·´×?Ö£ÎÜ|(iËS–O¹…D [şçğóí­Ş}KX¥\ì·3Ê–û2ìîİö¢ù+/İ˜#üõMÚğhÓğCÆÿ‰wd¥âŒÿIñ³wÚlùÑF÷¾È¼«şR³·4ÿß¢²óÿ1×pØ ­rX9hÿÿ5=¾¾ÿş3_|‰‚ÚŞ`ùô¶!œ@ôŞëıíÂ´ÇÃÿVÜ>~ë¸;ÿ,Ú1Ô/“Y¥¶íúºp2ÿúúµyà{¹E‹³ÓçÕä…QÁïƒá DÑKşÃó3+	¦ç4Íü‘…‚8¸Fn³ÑDGSupX™ØZ¿¨¦–îåÈ3­ÉvmeAÕ¹³‹iÈ"{9ûëBWaíˆ÷ÒËõˆ[~E—Ã{ÂfTC«Y¼¸µA•Í×'Æ¼]øy[§g¿SÑrŠ¨WâOæ÷øš{çÊ–;ù£{ø5(·‚áúnì>ÁùoÈépY C´çëo®{Î¼­œ®_©üs@e-öå¨‡ÉâàÌšõCnX„W„÷BâcSÂ‘;ëõˆdH@í]adK9ê>í(öZ‡!8‹ı7š$b¡sTn¦‹›g-èTx1'\O ı5Y­r‡‹|Á¾ÎHéiÌİ[:²a åš9”+l–m¢
´fgê\'r†ßäWÀiª¬qD&N
§¼¤jaÈòËÜ;¯¯#(;é\ÚÄÅ™¯À,1‹Ğ ïy;fÎC+tâñX%††°õçKÔÜ‡©Ï]h³ƒ¶‘®©§So0è`øyD©™º<—‘i˜*çğÎox6Áˆ2< kâ·öVÇ±t°êˆKïêª„²bøW«JmeÙ~ûH'‡=‚¿q^òün(å„×£mZ&F	ÿš\‰é0'.ßò‚o+Q“áËÅyPïİÜ¸‡‹™Ù?w·æ‡O²vYJlı†pƒ#ÿ¾4õ;èp3Ë=–âwà¾F†æåz­#X\ËKÅ)Ûd=P@(·’™6cÒ×Şn!ÄzÊ°•	àŸ8ûúV2‡àøƒ‡™'¯Ì#>IX–$÷kweŸˆ¤“9,ú•gî8òŠ±BŸxbÛ¬Mmû:Sˆ{ÑóêWî&~&Xf4Ÿnó t¾Ò‰‡¿p.2øJ5­Mı§q$O÷N;zÍyÏé‹æjÛNp`7ÀŸ'ó¤>¤›©æ¹á5–@\pğHä­Càx}(1nùµ³ùA~zá:,cŞy(é`îãÇ€©Q]±WÛì­Š6¾\
åW)(›Êf{[Œ2j ébƒã,ñwÖF_ëß|Ç×ø½aş•‰ÒqÇ¡o­âÊşƒÈï%8Ø:÷á¨;XÍZ!dëõ/ü ›eâ(’ÿöâl=UCĞxÎß:™µšF&‘*^WÖ(²„×_
MzĞ\™ú²…‹Âáf"1ÑC;™’Uì7×†#´™ùDÀÓÖb9D·Şlg7ûm÷Õ9|…½HqÑôÛÉ§&Tû˜å®lRŞÑ.vRí
I÷®¨–“¶¥IM… <ŞŸO<ıëÀ½úÙÁ1Ã½>_ÁlÚ%ã]è¼‡!Å©º/B8Ë$ôéÖ‰~sE_2Ÿ‚ÿë.pÆYÅõ×Ãè‚}Tó%Ì‡·][ŠãeK+ÿ¥5uRÃUZWi>:æ¬Sº_€ƒs¸~íPé4³'!ö¤ü™uB£=õLıé¶b0¦<`)†˜ı¿8yvëa¦ààRi™¶œX)6E8ìOmŸ ¦°Õ…/nÜµ¹ıT§¢&6¢^òÖË">tÃGÀº4Û#¿¦Õ%ÏêµŸû†¥¹G¹)¾*7óŒ„Ş`…®¨wŸ†Án³†’G‹ì•’×¹ÅÒ0õşíÙHh`—®JvÒÉ%~Xişuql¢º™åú¦AéııîÈãÂtº“Á6VMÀİ°iÏ±s2âb+ŸK–ª	)ÏaEûÖãÃÇœVN„ôıyZnsÕ‘¯ÿÍö–JÇö§tÔ˜¯Å„+2³&ä*ùÉB`.mnçcˆÒ‰Iôò[v?şËì'êÉ‡ğÏÆÖ™_cim¢Ãôl†r;‰¶mÓƒª#ÁqeÚú[”ÿ`Øc–H¯ ÿ#¡kŠO¼;aïC•H“à›af™=‡ÈÛÕ¿‚opmÄ:­½Š<c‡°*3oõYÅß¿tŞÁÆ°ETÛ1€6G…èıUÉ~ìíú¢zy›V¯m çğPÆ¦Ú%{Ó©O™ÇDÓ,®ì¶åøO5”fCÃí‡ÿW9Vç¬ä-š¢~àù“YóF/ ?ÿ|} iïnù‡\O´Û!*£H(3›A6F`<·h¨3y½ÀöÂûL¿¡&Ì0êäƒàÑ¾©“=æY¼Íİº¾ô.®¼áZÂ‡KT%âóÎû ı‡ÖõNQZÁMğĞl¦ù¥6)Æ0¸òàÂbÂ
°µ®Bg©Zk9Ë~Ó¦”®‘€>ô5+`j?0uu¹	FÜHKÌJm~:n³ˆ¼ÅÂ–Ühµñ!¯M,Ô„\‚ø<Â¢‡ÁÙõnëù±ë½›ãú|óÃÂÓ}¤vA—ºÏİöõ{A¼Ÿrvã7w1·_¹á\àz‰; \Û¤ğ°¡¥Îú
O¸X¯{­©æõÁí|I,}¨7×< 4¸ú¶›†ê7ĞG‡½÷B4¤.¡ÇP[tÌí÷Kµ>•½ 3°~¢jÓƒà¯c™UÅáb›­ÙEúJáô/zÜX\„µ©>-ÉIùPû6${9ÚàæíÁv›Êêu‚‰‡¯Wù|Qõ¾¢íñÑ¦å—1v`8Ë¸e‘WÆ+îÅ(#ù¼İ×X–Gâff?×üBd6°ìF³,9oD”Êµ˜~ÕX™ÃŞ[â„¡1Ì×ÕkM_rö\\;L8¢gø¹†±Š@²ÆV5ğëİyë_¥ÓBuC}bìèË6A²Êõ

4„B¡7¬½³-êT×Õ¡iäÊ‹2úª´í}¿]÷–ˆ7¨ÃlÖ¾„¼X	éh#úÈØƒ3~PA}+ ¹BÆ§X«éw@RÛÜÜs6ËR›ŠŸ¥ásÕWçÚï@àÎÍKC
‡NÆ G¬ÇÔÁ’mH;ªm©ÕÁ7BrpfwŸNõ&HCdŒÃéÑVl­Ì² “P«Sîqx3‚ÓÕg“”–nòïï†ğR¡$µ‘¥-²efÊ&f\¬[¬“šŞÈzx§l?&uësğğRâ–ƒ¼ëPZîïæ "E‰…üä"4e…S*Mø¹ús{ô½Cé/QRF/ Zßx‚u`DÃëªøÂÜVRëWzª9À ²P9ÆË§Ík”—È$ıˆY[‰•­Jqúév¤/GBXÜê0{…‚:¦0åÂ}J%1;pÿ³xºAhYbilÈÒ;\ìRëWB†2šÿ8ÜW§ †¯ñ{Ké{Êwï…ŒORù¡píäô>Üõ¶éô¬ö,Ut2·®w€ßàâ^ñÙ‰)^‡¸áÔsš·ª­l¥
ˆ>ÂùâE”À+F‚1vŒèRœ^Ñ',r°‡Š)Í7wâÆõ;$AÍz„ØGT«É'FJ²ôıçÉµÄ ~²:†6ÃHß¢#sˆû©®D»s‚(ñ~êf oV°öl³D—­Ö„]/´ßŠ<Œ!©…áÅİàª¬ğL»Lê“Z£Ñ —
˜u]0¬™8e›è[x¤¥	ÃíUÿì'¾IÂ¨Ë=[ù£5¤¸³£,/Ïyjû±Ôø©9¶J!¥r(„÷[¤#Ì<uHe–¸¢êøèj›ùíx¹íXùá÷›ú•çQÆÀsf…bEEtª]Qú%¿áH¸®ÈQ )ß¶¥=æÃd§õ‘S|áUİ…´ù™õà'ë c3‚hH*WhUh²Ó™•9(ŒŒ}p¼+]])^>.]+ ıƒTÅ(ı ³¤!´ÌNÀ0I¸€¢<u§\Ô]èF  5yßØ¹G•å.è©hªg¸Lã”Á#z¸çi ¤õêó‘x~¤ü™r³8QŒşR	U
Íì÷{'sH‰‹à zœk=${ø<@3à}e²3“pˆ¾ZO¸)z(BæE°B*¡VÖ~´(Xäw!˜»>¶“PWI3 «àQ
;"İÏkO/Ü¾£;~Åô±”øïV¯ŞôÜÉ†ÈÄ-zï:j1ŠÀt¹ñúî‰RF,\3¨íéşTEƒ…`w†Ğ‡€A0·n5¡Ò#cRñP¼Àh¦&ÑßÍ‘t $ïí×)fQk¾ä,öTéxÁÕplÈÚ:°ùw%%i)òLvõ+Ê’üïAÄx%İWÄrôÔPš_ˆ®ÌÙr\’¼¤±›¬d=QSzäÒ9ÈE­Ÿo>^š22¥­Ë%Í¡ùF3¢Â  ®„¾½›Aø"ŒCL²B™+K*XX‚ËÚ0ÜÉa6rÕĞî\Ù¬öTjrIùk½¶ "»®'lSMÆ:Œ7Dü*k¨\Øûp‘TJuZà'LlÛ™Ô°©^¨ÖÅƒøIs­
š ø<E1ÊĞáÒ•©Å±/)"ÚömWà«6®ü«Á„¾"î]è1á®Xë¢ÿĞD)¦Œî•À°?:"^qa†_p
I¨td<DƒcÈ±½œ­Ÿ`Üõï”¸ìlì¬Z8g¼ÏiŠ	ğQŞ4Up@ô'Pâ„Z¿k_A^mÇ< “GÇ-ïY?Ü .¨sa›fçwß#FTîN"„NŠĞ:—)b¥HUK °O”§d¥¶;Å~MâEíTƒqoC	r$ekì?!²}b*çíŠ¸P™ûˆEVP¾ñ¸®É* €Bd–¯`¶ØeÉæwyE	’­Òî·\à†MØUPÉÚ%wÄmµ|ïÆIËj¨ğ~ï¤Jì¤_{¢s½ğÉN;jï–õ3
F&«µ;gÁ$ù¥§iì„\<,ÕH0T€¯=?hè|úãS¬~‡‘q-H3¯DğiÉx¬ó³¨-àó5'H
TÔ»ŸúûEøÿvõ.a\ ‰‘‰ï„¾×ğ@‚M€aa¶@½2{‘bÀ1ÂÚu2İ0áœ“‰‚jL‘+C´uöI=Óá¼ZâİÈÆ#ïZ3…½>Úùó3wå€ôNáéF…äV‰®€l•Û‹®£½Ä@ı)G
÷{OsÀUÓ‚•P'8Ä…× ÂOM:Ïâæ×ƒŸò¯ÏŠ/j–æ0Ò=–Ğˆ¾–/Jê…”kÜÖJ‹*­8Eç²Â õœ9W›Ìd”Ûnõ¤‹—P<äÊå÷ìÅtR´ğ­®¡£¾ÉÄæW˜{!iÅ3"^›Šo`*"|x‰p·æ—³ãó¤á^°ƒˆ¨Zt—Î¥)WP—æ¥Õ°åõ¤GÎ!É°¶ñÔÊeé¨â—İ9)ğBXˆd’EC4‹×¬i‘³q4´nŒ€%¸è1ßÓÖ¸x™?è?òÓ¿5…Í0^å,U5LŸ¼CVİœ©iZL¸28ñå97Èãy*™G|Ûå`xE¶Á÷8½]D5ûfé„nà!’†5ñiw©H&ŞÈ)(Œ7"È>ãdßGQU_Aì¶˜ª¿y¸ıïzzù”–ó)G§†áj-1Ä?ælÎ°P3ÊvXŠ±àPBG‹U(p(!‘ãlm99¬‚S•&äk‰•2qÿ‘¶=ö‹”é%õTnŒŠÔöÊ/I.t‹æÛöEqNÅL8ˆ‰)ÿÅÑ'ó>4D	©uZ2İC6 ÑŠ>,bÁöÅvRG°}`"UrtP0ÙÆbfÅ½~‡ŞöÇ¶_næìksDŠ5/Aˆ*/{–4r6Â¤â„ ×õ+4—ã8„G>Êõ“"4ë$iñ—L>œOğ¼¬P-8cá¥r<òEvØ²«É`Ê¯+`†tvÃ\Üæe¯°Ù‰‚%´Å¾åÖ¡wõ,Ì$ª§^4‡ÊËÖ	¨bŞ#tjÂqk²$(ú"z]ãêÏ‚Œ<H¨&@¡…
Ø¤vŠ–Ëa
©WKÂııJœy\Å“t†åàÖ ‡z½Şöä‰H9äªh!jmrB.%Wüx`ÊÓPv‹ô_òún;¹‚älÃô› ÕYnVÒµ^Ï JIÃNÆÂ